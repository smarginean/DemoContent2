// -----------------------------------------------------------------------
//  <copyright file="Context.cs" company="SDL plc">
//   Copyright (c) SDL plc. All rights reserved.
//  </copyright>
// -----------------------------------------------------------------------
namespace Sdl.Connectors.MarketoContext
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;
    using Sdl.Connectors.Common.Contract.Authorization;
    using Sdl.Connectors.Common.Contract.ConnectedInfo;
    using Sdl.Connectors.Common.Contract.Exception;
    using Sdl.Connectors.Common.Extension.Identity;
    using Sdl.Connectors.MarketoService.Contract.Context;
    using Sdl.Connectors.MarketoService.Contract.Context.Strategy;
    using Sdl.Connectors.MarketoService.Core.Strategy;
    using Sdl.Connectors.MarketoService.Model;

    /// <summary>
    /// 
    /// </summary>
    /// <seealso cref="Sdl.Connectors.MarketoService.Contract.Context.IContext" />
    public class Context : IContext
    {
        /// <summary>
        /// The authentication handler
        /// </summary>
        private IAuthStrategy authStrategy;

        /// <summary>
        /// The strategies
        /// </summary>
        protected readonly Dictionary<ContentCategory, IStrategy> strategies =
            new Dictionary<ContentCategory, IStrategy>();

        /// <summary>
        /// The supported feature types
        /// </summary>
        private List<SupportedFeatureType> supportedFeatureTypes;

        /// <summary>
        /// Initializes a new instance of the <see cref="Context"/> class.
        /// </summary>
        public Context()
        {
            this.supportedFeatureTypes = new List<SupportedFeatureType>();
            this.AuthenticationEntity = new AuthenticationEntity { Configuration = new ConfigurationItem(), Token = new OAuthToken() };
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Context" /> class.
        /// </summary>
        /// <param name="authenticationEntity">The authentication entity.</param>
        /// <param name="supportedFeatureTypes">The supported feature types.</param>
        public Context(AuthenticationEntity authenticationEntity, List<SupportedFeatureType> supportedFeatureTypes = null)
        {
            this.supportedFeatureTypes = supportedFeatureTypes;
            this.AuthenticationEntity = authenticationEntity;
        }

        /// <summary>
        /// Gets the authentication entity.
        /// </summary>
        /// <value>
        /// The authentication entity.
        /// </value>
        public AuthenticationEntity AuthenticationEntity { get; private set; }

        /// <summary>
        /// Authenticates the specified settings.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorAuthenticationException">
        /// </exception>
        /// <exception cref="ConnectorException"></exception>
        public async Task<OAuthToken> Authenticate(CancellationToken cancellationToken = default(CancellationToken))
        {
            if (!this.AuthenticationEntity.Configuration.IsValid())
            {
                throw new ConnectorAuthenticationException($"Authenticate error. {this.AuthenticationEntity.Configuration.Info()}");
            }
            try
            {
                this.SetupAuthStrategy();
                this.AuthenticationEntity = await this.authStrategy.Refresh(this.AuthenticationEntity, cancellationToken).ConfigureAwait(false);

                return this.AuthenticationEntity.Token;
            }
            catch (ConnectorException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConnectorAuthenticationException($"Authenticate error. {this.AuthenticationEntity.Info()}", ex);
            }
        }

        /// <summary>
        /// Disconnects the specified cancellation token.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorAuthenticationException"></exception>
        public Task Disconnect(CancellationToken cancellationToken = default(CancellationToken))
        {
            try
            {
                this.AuthenticationEntity = null;

                return Task.CompletedTask;
            }
            catch (ConnectorException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConnectorAuthenticationException(
                    $"Disconnect failed. {this.AuthenticationEntity?.Configuration.Info()}", ex);
            }
        }

        /// <summary>
        /// Determines whether the specified cancellation token is authenticated.
        /// </summary>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorAuthenticationException"></exception>
        public async Task<bool> IsAuthenticated(CancellationToken cancellationToken = default(CancellationToken))
        {
            try
            {
                if (this.AuthenticationEntity == null || !this.AuthenticationEntity.Configuration.IsValid())
                {
                    return false;
                }

                if (this.AuthenticationEntity.Token.IsValid())
                {
                    return true;
                }

                this.AuthenticationEntity.Token = await this.Authenticate(cancellationToken).ConfigureAwait(false);

                if (this.AuthenticationEntity.Token.IsValid())
                {
                    return true;
                }

                return false;
            }
            catch (ConnectorException)
            {
                return false;
            }
            catch (Exception ex)
            {
                throw new ConnectorAuthenticationException(
                    $"IsAuthenticated failed. {this.AuthenticationEntity?.Configuration.Info()}", ex);
            }
        }

        #region updateContent

        /// <summary>
        /// Updates the specified category.
        /// </summary>
        /// <param name="originalFileId">The original file identifier.</param>
        /// <param name="languageCode">The language code.</param>
        /// <param name="fileContent">Content of the file.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorException">
        /// </exception>
        public async Task UpdateContent(string originalFileId,
                           string languageCode,
                           Stream fileContent, 
                           CancellationToken cancellationToken = default(CancellationToken))
        {
            if (string.IsNullOrWhiteSpace(originalFileId))
            {
                throw new ConnectorException($"UpdateContent originalFileId={originalFileId} languageCode={languageCode}");
            }

            try
            {
                await this.Authenticate(cancellationToken).ConfigureAwait(false);

                this.SetupStrategies(this.AuthenticationEntity);

                ConnectedSystemIdentity identity = ConnectedSystemIdentityHelper.Decode(originalFileId);

                ContentCategory contentCategory;
                if (!Enum.TryParse(identity.Context, out contentCategory))
                {
                    throw new ConnectorException($"UpdateContent originalFileId={originalFileId} languageCode={languageCode} {this.AuthenticationEntity?.Configuration.Info()}");
                }

                IStrategy strategy = this.strategies[contentCategory];
                if (strategy is IContentStrategy)
                {
                    await ((IContentStrategy) strategy).Update(identity.Id, languageCode, fileContent, cancellationToken).ConfigureAwait(false);
                }
                else
                {
                    throw new ConnectorException($"UpdateContent originalFileId={originalFileId} languageCode={languageCode} {this.AuthenticationEntity?.Configuration.Info()}");
                }
            }
            catch (ConnectorException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConnectorException($"UpdateContent originalFileId={originalFileId} languageCode={languageCode}{this.AuthenticationEntity?.Configuration.Info()}", ex);
            }
        }

        #endregion

        #region getFileById

        /// <summary>
        /// Gets the file by identifier.
        /// </summary>
        /// <param name="category">The category.</param>
        /// <param name="contentId">The content identifier.</param>
        /// <param name="parentId">The parent identifier.</param>
        /// <param name="contentStatus">The content status.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorException">
        /// </exception>
        public async Task<ConnectedFileSystemEntry> GetContentInfoById(ContentCategory category,
                                                      string contentId,
                                                      string parentId = null,
                                                      ContentStatus? contentStatus = null, 
                                                      CancellationToken cancellationToken = default(CancellationToken))
        {
            if (string.IsNullOrWhiteSpace(contentId))
            {
                throw new ConnectorException($"GetContentInfoById failed, id is empty or null. category={category} contentId={contentId} parentId={parentId} contentStatus={contentStatus} ");
            }
            try
            {
                await this.Authenticate(cancellationToken).ConfigureAwait(false);

                this.SetupStrategies(this.AuthenticationEntity);

                IStrategy strategy = this.strategies[category];

                ConnectedFileSystemEntry connectedFileSystemEntry = null;
                if (strategy is IContentStrategy)
                {
                    connectedFileSystemEntry = await ((IContentStrategy)strategy).GetById(contentId, category, parentId, contentStatus, cancellationToken).ConfigureAwait(false);
                }

                if (strategy is IPreviewStrategy)
                {
                    connectedFileSystemEntry = await ((IPreviewStrategy)strategy).GetById(category, contentId, parentId, contentStatus, cancellationToken).ConfigureAwait(false);
                }

                if (connectedFileSystemEntry != null)
                {
                    return connectedFileSystemEntry;
                }

                throw new ConnectorException($"GetContentInfoById failed, system entry is null. category={category} contentId={contentId} parentId={parentId} contentStatus={contentStatus} {this.AuthenticationEntity?.Configuration.Info()}");
            }
            catch (ConnectorException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConnectorException($"GetContentInfoById failed, exception. category={category} contentId={contentId} parentId={parentId} contentStatus={contentStatus} {this.AuthenticationEntity?.Configuration.Info()}", ex);
            }
        }

        #endregion

        #region GetFileInfo

        /// <summary>
        /// Gets the file information.
        /// </summary>
        /// <param name="id">The identifier.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorAuthenticationException">
        /// </exception>
        /// <exception cref="ConnectorException"></exception>
        public async Task<ConnectedFile> GetFileInfo(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (!this.AuthenticationEntity.Configuration.IsValid())
            {
                throw new ConnectorAuthenticationException($"GetFileInfo error. {this.AuthenticationEntity.Configuration.Info()}");
            }

            if (string.IsNullOrWhiteSpace(id))
            {
                throw new ConnectorAuthenticationException($"GetFileInfo. fileId={id} {this.AuthenticationEntity.Configuration.Info()}");
            }

            try
            {
                await this.Authenticate(cancellationToken).ConfigureAwait(false);

                this.SetupStrategies(this.AuthenticationEntity);

                ConnectedSystemIdentity identity = ConnectedSystemIdentityHelper.Decode(id);

                ContentCategory contentCategory;
                Enum.TryParse(identity.Context, out contentCategory);

                ConnectedFileSystemEntry connectedFile;
                ContentStatus contentStatus;
                if (!Enum.TryParse(identity.Status, out contentStatus))
                {
                    connectedFile = await this.GetContentInfoById(contentCategory, identity.Id, identity.ParentId, cancellationToken: cancellationToken).ConfigureAwait(false);
                }
                else
                {
                    connectedFile = await this.GetContentInfoById(contentCategory, identity.Id, identity.ParentId, contentStatus, cancellationToken: cancellationToken).ConfigureAwait(false);
                }

                return connectedFile as ConnectedFile;
            }
            catch (ConnectorException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConnectorException($"GetFileInfo failed. id={id} {this.AuthenticationEntity.Configuration.Info()}", ex);
            }
        }

        #endregion

        #region GetFolderInfo

        /// <summary>
        /// Gets the folder information.
        /// </summary>
        /// <param name="id">The identifier.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorAuthenticationException"></exception>
        /// <exception cref="ConnectorException">
        /// </exception>
        public async Task<ConnectedFolder> GetFolderInfo(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (!this.AuthenticationEntity.Configuration.IsValid())
            {
                throw new ConnectorAuthenticationException($"GetFolderInfo error. {this.AuthenticationEntity.Configuration.Info()}");
            }

            if (string.IsNullOrWhiteSpace(id))
            {
                throw new ConnectorException($"GetFolderInfo failed. id={id} {this.AuthenticationEntity?.Configuration.Info()}");
            }

            try
            {
                await this.Authenticate(cancellationToken).ConfigureAwait(false);

                this.SetupStrategies(this.AuthenticationEntity);

                ConnectedSystemIdentity identity = ConnectedSystemIdentityHelper.Decode(id);

                ConnectedFolder connectedFolder = new ConnectedFolder(identity.Name)
                {
                    Id = id,
                    ParentId = identity.ParentId,
                    FullName = identity.Name
                };

                return await Task.FromResult(connectedFolder);
            }
            catch (ConnectorException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConnectorException($"GetFolderInfo failed. id={id} {this.AuthenticationEntity.Configuration.Info()}", ex);
            }
        }

        #endregion

        /// <summary>
        /// Setups the authentication strategy.
        /// </summary>
        private void SetupAuthStrategy()
        {
            if (this.authStrategy == null)
            {
                this.authStrategy = new AuthStrategy();
            }
        }

        /// <summary>
        /// Setups the strategies.
        /// </summary>
        /// <param name="authenticationEntity">The authentication entity.</param>
        private void SetupStrategies(AuthenticationEntity authenticationEntity)
        {
            if (this.supportedFeatureTypes == null)
            {
                this.supportedFeatureTypes = new List<SupportedFeatureType>();
            }

            if (this.authStrategy == null)
            {
                this.authStrategy = new AuthStrategy();
            }

            if (this.strategies.Count == 0)
            {
                this.strategies.Add(ContentCategory.Folder, new FolderStrategy(authenticationEntity, this.supportedFeatureTypes));
                this.strategies.Add(ContentCategory.TemplateFolder, new FolderTemplateStrategy(authenticationEntity, this.supportedFeatureTypes));
                this.strategies.Add(ContentCategory.Channel, new ChannelStrategy(authenticationEntity, this.supportedFeatureTypes));
                this.strategies.Add(ContentCategory.Program, new ProgramStrategy(authenticationEntity, this.supportedFeatureTypes));
                this.strategies.Add(ContentCategory.Email, new UnifiedEmailStrategy(authenticationEntity, this.supportedFeatureTypes));
                this.strategies.Add(ContentCategory.Preview, new EmailCustomPreviewStrategy(authenticationEntity, this.supportedFeatureTypes));
                this.strategies.Add(ContentCategory.EmailTemplate, new EmailTemplateStrategy(authenticationEntity, this.supportedFeatureTypes));
                this.strategies.Add(ContentCategory.ProgramEmailFolder, new ProgramFolderEmailStrategy(authenticationEntity, this.supportedFeatureTypes));
                this.strategies.Add(ContentCategory.LandingPage, new LandingPagesStrategy(authenticationEntity, this.supportedFeatureTypes));
                this.strategies.Add(ContentCategory.Form, new FormsStrategy(authenticationEntity, this.supportedFeatureTypes));

            }
        }

        #region download

        /// <summary>
        /// Downloads the specified category.
        /// </summary>
        /// <param name="id">The identifier.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorAuthenticationException"></exception>
        /// <exception cref="ConnectorException">
        /// </exception>
        public async Task<Stream> Download(string id, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (!this.AuthenticationEntity.Configuration.IsValid())
            {
                throw new ConnectorAuthenticationException($"Download error. {this.AuthenticationEntity.Configuration.Info()}");
            }

            if (string.IsNullOrWhiteSpace(id))
            {
                throw new ConnectorException($"Download failed. id={id} {this.AuthenticationEntity?.Configuration.Info()}");
            }
            try
            {
                await this.Authenticate(cancellationToken).ConfigureAwait(false);

                this.SetupStrategies(this.AuthenticationEntity);

                ConnectedSystemIdentity identity = ConnectedSystemIdentityHelper.Decode(id);

                ContentCategory contentCategory;
                Enum.TryParse(identity.Context, out contentCategory);

                ContentStatus contentStatus;
                Enum.TryParse(identity.Status, out contentStatus);

                return await this.Download(contentCategory, identity.Id, contentStatus, cancellationToken).ConfigureAwait(false);
            }
            catch (ConnectorException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConnectorException($"Download id={id} {this.AuthenticationEntity.Info()}", ex);
            }
        }

        /// <summary>
        /// Downloads the specified category.
        /// </summary>
        /// <param name="category">The category.</param>
        /// <param name="id">The identifier.</param>
        /// <param name="contentStatus">The content status.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorAuthenticationException"></exception>
        /// <exception cref="ConnectorException">
        /// </exception>
        public async Task<Stream> Download(ContentCategory category, string id, ContentStatus? contentStatus = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (!this.AuthenticationEntity.Configuration.IsValid())
            {
                throw new ConnectorAuthenticationException($"Download error. {this.AuthenticationEntity.Configuration.Info()}");
            }

            if (string.IsNullOrWhiteSpace(id))
            {
                throw new ConnectorException($"Download={category} id={id} contentStatus={contentStatus} {this.AuthenticationEntity?.Configuration.Info()}");
            }
            try
            {
                await this.Authenticate(cancellationToken).ConfigureAwait(false);

                this.SetupStrategies(this.AuthenticationEntity);

                Stream downloadContent;

                IStrategy strategy = this.strategies[category];
                if (strategy is IContentStrategy)
                {
                    downloadContent = await ((IContentStrategy)strategy).Download(id, contentStatus, cancellationToken).ConfigureAwait(false);
                    return downloadContent;

                }
                if (strategy is IPreviewStrategy)
                {
                    downloadContent = await ((IPreviewStrategy)strategy).Download(id, contentStatus, cancellationToken).ConfigureAwait(false);
                    return downloadContent;
                }

                throw new ConnectorException($"Download failed, invalid content. category={category} id={id} contentStatus={contentStatus} {this.AuthenticationEntity?.Configuration.Info()}");
            }
            catch (ConnectorException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConnectorException($"Download failed, exception found. category={category} id={id} contentStatus={contentStatus} {this.AuthenticationEntity?.Configuration.Info()}", ex);
            }
        }

        #endregion

        #region GetConnectedFileSystemEntryList

        /// <summary>
        /// Gets the content information list.
        /// </summary>
        /// <param name="id">The identifier.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorAuthenticationException">GetContentInfoList. Configuration is null or empty.
        /// or</exception>
        /// <exception cref="ConnectorException"></exception>
        public async Task<List<ConnectedFileSystemEntry>> GetContentInfoList(string id = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            if (this.AuthenticationEntity == null)
            {
                throw new ConnectorAuthenticationException("GetContentInfoList. Configuration is null or empty.");
            }

            if (!this.AuthenticationEntity.Configuration.IsValid())
            {
                throw new ConnectorAuthenticationException($"GetContentInfoList error. id={id} {this.AuthenticationEntity.Configuration.Info()}");
            }
            try
            {
                await this.Authenticate(cancellationToken).ConfigureAwait(false);

                this.SetupStrategies(this.AuthenticationEntity);

                List<ConnectedFileSystemEntry> connectedFileSystemList;
                if (string.IsNullOrWhiteSpace(id))
                {
                    connectedFileSystemList =
                        await this.GetContentInfoList(null, id: null, parentId: null,
                            cancellationToken: cancellationToken).ConfigureAwait(false);
                }
                else
                {
                    ConnectedSystemIdentity identity = ConnectedSystemIdentityHelper.Decode(id);

                    ContentCategory contentCategory;
                    Enum.TryParse(identity.Context, out contentCategory);

                    ContentStatus contentStatus;
                    if (!Enum.TryParse(identity.Status, out contentStatus))
                    {
                        connectedFileSystemList =
                            await this.GetContentInfoList(contentCategory, id: identity.Id, 
                                parentId: identity.ParentId, parentContext: identity.Context,  cancellationToken: cancellationToken).ConfigureAwait(false);
                    }
                    else
                    {
                        connectedFileSystemList =
                            await this.GetContentInfoList(contentCategory, id: identity.Id,
                                parentId: identity.ParentId, parentContext: identity.Context, contentStatus: contentStatus, 
                                cancellationToken: cancellationToken).ConfigureAwait(false);
                    }
                }
                return connectedFileSystemList;
            }
            catch (ConnectorException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConnectorException($"GetContentInfoList id={id} {this.AuthenticationEntity?.Configuration.Info()}", ex);
            }
        }

        /// <summary>
        /// Gets the connected file system entry list.
        /// </summary>
        /// <param name="category">The category.</param>
        /// <param name="id">The identifier.</param>
        /// <param name="parentId">The parent identifier.</param>
        /// <param name="contentStatus">The content status.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorAuthenticationException"></exception>
        /// <exception cref="ConnectorException"></exception>
        public async Task<List<ConnectedFileSystemEntry>> GetContentInfoList(ContentCategory? category = null,
                                                                             string id = null,
                                                                             string parentId = null,
                                                                             string parentContext = null,
                                                                             ContentStatus? contentStatus = null,
                                                                             CancellationToken cancellationToken = default(CancellationToken))
        {

            if (!this.AuthenticationEntity.Configuration.IsValid())
            {
                throw new ConnectorAuthenticationException(
                    $"GetContentInfoList error. {this.AuthenticationEntity.Configuration.Info()}");
            }
            try
            {
               await this.Authenticate(cancellationToken).ConfigureAwait(false);

                this.SetupStrategies(this.AuthenticationEntity);

                List<ConnectedFileSystemEntry> connectedSystemEntryList = null;

                if (category == null)
                {
                    connectedSystemEntryList =
                        await this.GetRootConnectedFileSystemEntryList(contentCategory: null, status: contentStatus, cancellationToken: cancellationToken)
                                  .ConfigureAwait(false);

                    return connectedSystemEntryList;
                }
                IStrategy strategy = this.strategies[category.Value];

                connectedSystemEntryList = await strategy.GetAll(category, id, parentId, parentContext, contentStatus,
                                                                 cancellationToken).ConfigureAwait(false);

                return connectedSystemEntryList;
            }
            catch (ConnectorException ex)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new ConnectorException(
                                             $"GetContentInfoList exception. category={category} id={id} parentId={parentId} contentStatus={contentStatus} {this.AuthenticationEntity?.Configuration.Info()}",
                                             ex);
            }
        }

        /// <summary>
        /// Gets the root connected file system entry list.
        /// </summary>
        /// <param name="contentCategory">The content category.</param>
        /// <param name="status">The status.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        /// <exception cref="ConnectorException"></exception>
        private async Task<List<ConnectedFileSystemEntry>> GetRootConnectedFileSystemEntryList(
            ContentCategory? contentCategory, 
            ContentStatus? status = null, 
            CancellationToken cancellationToken = default(CancellationToken))
        {
            List<ConnectedFileSystemEntry> connectedFileSystemEntryList;
            int contentCategoryIndex;

            if (contentCategory == null)
            {
                int minIndexValue = this.strategies.Keys.Select(x=>(int)x).Concat(new[] {int.MaxValue}).Min();
                contentCategoryIndex = minIndexValue;

                connectedFileSystemEntryList = await this.strategies[(ContentCategory)contentCategoryIndex].GetAll(contentStatus: status, cancellationToken: cancellationToken).ConfigureAwait(false);

                while (contentCategoryIndex != this.strategies.Keys.Count)
                {
                    contentCategoryIndex++;
                    if (connectedFileSystemEntryList.Count == 0)
                    {
                        connectedFileSystemEntryList = await this.strategies[(ContentCategory)contentCategoryIndex].GetAll(contentStatus: status, cancellationToken: cancellationToken).ConfigureAwait(false);

                        if (connectedFileSystemEntryList.Count > 0)
                        {
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else
            {
                contentCategoryIndex = (int) contentCategory;
                connectedFileSystemEntryList = await this.strategies[(ContentCategory)contentCategoryIndex].GetAll(contentCategory, contentStatus: status, cancellationToken : cancellationToken).ConfigureAwait(false);
            }

            return connectedFileSystemEntryList;
        }

        #endregion
    }
}